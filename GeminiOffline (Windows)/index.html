<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chat</title>
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">
    <!-- Theme color for browser UI -->
    <meta name="theme-color" content="#1e293b"/>
    <!-- Link to a generic icon for PWA -->
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/1e293b/ffffff?text=GC">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { --sidebar-width: 280px; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .typing-indicator { display: flex; align-items: center; gap: 4px; }
        .typing-indicator span { width: 8px; height: 8px; border-radius: 50%; background-color: #94a3b8; animation: bounce 1.4s infinite ease-in-out both; }
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        
        #sidebar {
            width: var(--sidebar-width);
            transition: margin-left 0.3s ease-in-out;
        }
        #sidebar.collapsed {
            margin-left: calc(-1 * var(--sidebar-width));
        }
        #main-content {
            transition: width 0.3s ease-in-out;
            width: 100%;
        }
        .sidebar-open #main-content {
            width: calc(100% - var(--sidebar-width));
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans flex h-screen overflow-hidden">

    <!-- Collapsible Sidebar -->
    <aside id="sidebar" class="bg-slate-800 flex flex-col h-full flex-shrink-0 border-r border-slate-700">
        <div class="flex items-center justify-between p-4 border-b border-slate-700">
            <h2 class="text-lg font-bold text-slate-200">Chats</h2>
            <button id="refreshChatsBtn" title="Refresh Chat List" class="p-1 text-slate-400 hover:text-white hover:bg-slate-700 rounded">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </button>
        </div>
        <ul id="chat-list" class="flex-1 overflow-y-auto p-2 space-y-1">
            <!-- Chat items will be dynamically inserted here -->
        </ul>
    </aside>

    <!-- Main Content Area -->
    <div id="main-content" class="flex flex-col h-screen">
        <!-- Header Section -->
        <header class="bg-slate-800 p-4 shadow-md flex justify-between items-center z-10 border-b border-slate-700">
            <div class="flex items-center gap-4">
                <button id="toggleSidebarBtn" title="Toggle Sidebar" class="p-1 text-slate-400 hover:text-white hover:bg-slate-700 rounded">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                </button>
                <h1 class="text-xl font-bold text-slate-200">Gemini Chat</h1>
            </div>
            <div class="flex items-center space-x-4">
                 <div class="flex items-center space-x-2 bg-slate-700 px-2 py-1 rounded-md">
                     <button id="setupFolderBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-0.5 px-2 rounded-md transition-colors text-xs">Setup Storage Folder</button>
                    <span id="storageFolderName" class="text-xs text-slate-400 max-w-[100px] truncate" title="No storage folder set.">None</span>
                </div>
                <button id="exportChatBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-md transition-colors text-sm">Export Chat</button>
                 <div class="relative">
                    <input type="password" id="apiKeyInput" placeholder="Enter API Key" class="w-48 bg-slate-700 text-slate-300 rounded-md py-1 px-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-300">
                    <button id="saveApiKey" class="absolute right-1 top-1/2 -translate-y-1/2 bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-bold py-0.5 px-2 rounded transition-colors">Save</button>
                </div>
                <select id="modelSelector" class="bg-slate-700 text-slate-300 rounded-md py-1 px-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-300">
                    <option value="gemini-1.5-pro-latest">Gemini 1.5 Pro</option>
                    <option value="gemini-1.5-flash-latest">Gemini 1.5 Flash</option>
                </select>
            </div>
        </header>

        <!-- Chat Messages Area -->
        <main id="chat-container" class="flex-1 p-4 overflow-y-auto">
            <div id="message-area" class="max-w-4xl mx-auto flex flex-col space-y-4">
                <!-- Chat messages appear here -->
            </div>
        </main>

        <!-- Message Input Section -->
        <footer class="bg-slate-800 p-4 shadow-up">
            <div class="max-w-4xl mx-auto">
                <form id="message-form" class="flex items-center bg-slate-700 rounded-lg p-2">
                    <textarea id="message-input" placeholder="Type your message..." class="flex-1 bg-transparent text-slate-200 focus:outline-none resize-none px-2" rows="1"></textarea>
                    <button type="submit" class="bg-indigo-600 text-white rounded-md p-2 ml-2 hover:bg-indigo-700 transition-colors disabled:bg-slate-500 disabled:cursor-not-allowed">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </form>
            </div>
        </footer>
    </div>

    <script>
        // --- DOM Elements ---
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        const messageArea = document.getElementById('message-area');
        const modelSelector = document.getElementById('modelSelector');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKey');
        const exportChatBtn = document.getElementById('exportChatBtn');
        const setupFolderBtn = document.getElementById('setupFolderBtn');
        const storageFolderNameSpan = document.getElementById('storageFolderName');
        const sidebar = document.getElementById('sidebar');
        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
        const refreshChatsBtn = document.getElementById('refreshChatsBtn');
        const chatListUl = document.getElementById('chat-list');
        const mainContent = document.getElementById('main-content');
        const body = document.body;

        // --- State Variables ---
        let apiKey = localStorage.getItem('gemini-api-key') || '';
        if (apiKey) apiKeyInput.value = apiKey;
        let db;
        let appStorageHandle = null;
        let currentChatHistory = [];
        let isCurrentChatSaved = true;

        // --- IndexedDB Functions ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('geminiWebAppDB', 1);
                request.onupgradeneeded = e => e.target.result.createObjectStore('handles');
                request.onsuccess = e => { db = e.target.result; resolve(db); };
                request.onerror = e => { console.error('IndexedDB error:', e.target.errorCode); reject(e.target.errorCode); };
            });
        }

        function setHandle(key, value) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['handles'], 'readwrite');
                tx.objectStore('handles').put(value, key);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        function getHandle(key) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['handles'], 'readonly');
                const request = tx.objectStore('handles').get(key);
                tx.oncomplete = () => resolve(request.result);
                tx.onerror = () => reject(tx.error);
            });
        }

        // --- Permission Verification ---
        async function verifyPermission(handle, withRequest = false) {
            const options = { mode: 'readwrite' };
            if ((await handle.queryPermission(options)) === 'granted') return true;
            if (withRequest && (await handle.requestPermission(options)) === 'granted') return true;
            return false;
        }

        // --- Event Listeners ---
        window.addEventListener('load', async () => {
            if (!('showDirectoryPicker' in window)) {
                alert('Your browser does not support the File System Access API. This app requires a modern browser like Chrome or Edge.');
                return;
            }
            await initDB();
            await loadAppStorageFolder();
            startNewChat();
            if (localStorage.getItem('sidebar-collapsed') === 'true') {
                toggleSidebar(true);
            } else {
                 body.classList.add('sidebar-open');
            }
        });

        saveApiKeyBtn.addEventListener('click', () => {
            apiKey = apiKeyInput.value.trim();
            if (apiKey) {
                localStorage.setItem('gemini-api-key', apiKey);
                alert('API Key saved!');
            } else {
                alert('Please enter a valid API Key.');
            }
        });

        setupFolderBtn.addEventListener('click', async () => {
            try {
                const handle = await window.showDirectoryPicker();
                if (await verifyPermission(handle, true)) {
                    appStorageHandle = handle;
                    await setHandle('appStorageHandle', handle);
                    updateStorageFolderNameUI(handle.name, true);
                    await refreshChatList();
                }
            } catch (error) {
                if (error.name !== 'AbortError') console.error('Error picking directory:', error);
            }
        });

        toggleSidebarBtn.addEventListener('click', () => toggleSidebar());
        refreshChatsBtn.addEventListener('click', refreshChatList);
        messageForm.addEventListener('submit', handleSendMessage);
        exportChatBtn.addEventListener('click', exportChat);
        messageInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); messageForm.dispatchEvent(new Event('submit')); } });
        messageInput.addEventListener('input', () => { messageInput.style.height = 'auto'; messageInput.style.height = `${messageInput.scrollHeight}px`; });

        // --- Core Application Logic ---
        
        async function loadAppStorageFolder() {
            const handle = await getHandle('appStorageHandle');
            if (!handle) { updateStorageFolderNameUI(null); return; }
            const hasPermission = await verifyPermission(handle, false);
            updateStorageFolderNameUI(handle.name, hasPermission);
            if (hasPermission) {
                appStorageHandle = handle;
                await refreshChatList();
            }
        }

        async function handleSendMessage(e) {
            e.preventDefault();
            const userMessage = messageInput.value.trim();
            if (!userMessage) return;
            if (!apiKey) { alert("Please enter and save your API Key first."); return; }
            
            appendMessage(userMessage, 'user');
            messageInput.value = '';
            messageInput.style.height = 'auto';
            showTypingIndicator();

            if (isCurrentChatSaved) {
                isCurrentChatSaved = false;
                await refreshChatList();
            }
            
            try {
                const model = modelSelector.value;
                const geminiResponse = await getGeminiResponse(userMessage, model);
                removeTypingIndicator();
                appendMessage(geminiResponse, 'gemini');
            } catch (error) {
                console.error("Error fetching Gemini response:", error);
                removeTypingIndicator();
                appendMessage(`Error: ${error.message}`, 'gemini', true);
            }
        }

        async function exportChat() {
            if (!appStorageHandle) { alert("Please set a storage folder first."); return; }
            if (isCurrentChatSaved) { alert("No new messages to export."); return; }
            
            const date = new Date();
            const timestamp = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}_${String(date.getHours()).padStart(2, '0')}-${String(date.getMinutes()).padStart(2, '0')}`;
            const firstMessage = currentChatHistory.length > 0 ? currentChatHistory[0].text.substring(0, 20).replace(/\s+/g, '_') : 'chat';
            const fileName = `${timestamp}_${firstMessage}.txt`;

            let chatContent = '';
            currentChatHistory.forEach(msg => {
                chatContent += `${msg.sender === 'user' ? 'User' : 'Gemini'}: ${msg.text}\n\n`;
            });
            
            try {
                const fileHandle = await appStorageHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(chatContent);
                await writable.close();
                alert(`Chat exported to "${fileName}"`);
                isCurrentChatSaved = true;
                await refreshChatList();
            } catch (error) {
                console.error('Error saving file:', error);
                alert(`Could not save file. Please re-verify folder permissions.`);
            }
        }

        async function refreshChatList() {
            chatListUl.innerHTML = '';
            if (!isCurrentChatSaved) {
                addChatItem('Current Chat', false, () => {});
            }

            if (!appStorageHandle || !(await verifyPermission(appStorageHandle, false))) {
                const placeholder = document.createElement('li');
                placeholder.className = 'text-xs text-slate-500 px-3 py-2';
                placeholder.textContent = 'Set storage folder to see saved chats.';
                chatListUl.appendChild(placeholder);
                return;
            }

            const files = [];
            for await (const entry of appStorageHandle.values()) {
                if (entry.kind === 'file' && entry.name.endsWith('.txt')) {
                    files.push(entry);
                }
            }
            
            files.sort((a, b) => b.name.localeCompare(a.name));

            files.forEach(file => {
                addChatItem(file.name, true, () => loadChatFromFile(file.name));
            });
        }

        function addChatItem(name, isSaved, onClick) {
            const li = document.createElement('li');
            li.className = 'flex items-center gap-3 px-3 py-2 rounded-md text-sm font-medium cursor-pointer text-slate-300 hover:bg-slate-700';
            const icon = document.createElement('span');
            icon.innerHTML = isSaved
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-400"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>`;

            const text = document.createElement('span');
            text.textContent = isSaved ? name.replace('.txt', '') : name;
            text.className = 'truncate';

            li.appendChild(icon);
            li.appendChild(text);
            li.addEventListener('click', onClick);
            chatListUl.appendChild(li);
        }

        async function loadChatFromFile(fileName) {
            if (!appStorageHandle) return;
            try {
                const fileHandle = await appStorageHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const content = await file.text();
                
                messageArea.innerHTML = '';
                currentChatHistory = [];
                
                const messageBlocks = content.trim().split('\n\n');
                messageBlocks.forEach(block => {
                    const parts = block.split(': ');
                    const senderLabel = parts[0];
                    const text = parts.slice(1).join(': ');
                    const sender = senderLabel === 'User' ? 'user' : 'gemini';
                    appendMessage(text, sender, false, false); // Don't re-add to history
                });
                isCurrentChatSaved = true;
                await refreshChatList();
            } catch (error) {
                console.error('Error loading chat:', error);
                alert(`Failed to load chat: ${error.message}`);
            }
        }

        function startNewChat() {
            messageArea.innerHTML = '';
            currentChatHistory = [];
            isCurrentChatSaved = true;
            appendMessage('Hello! How can I help you today?', 'gemini', false, false);
            refreshChatList();
        }

        // --- UI & Helper Functions ---

        function toggleSidebar(forceCollapse = null) {
            const isCollapsed = sidebar.classList.toggle('collapsed', forceCollapse);
            body.classList.toggle('sidebar-open', !isCollapsed);
            localStorage.setItem('sidebar-collapsed', isCollapsed);
        }

        function appendMessage(text, sender, isError = false, addToHistory = true) {
            if (addToHistory) currentChatHistory.push({ text, sender });
            const msgWrapper = document.createElement('div');
            const msgBubble = document.createElement('div');
            msgWrapper.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            msgBubble.className = `rounded-lg p-3 max-w-xl lg:max-w-2xl shadow break-words ${sender === 'user' ? 'bg-indigo-600 text-white' : isError ? 'bg-red-500 text-white' : 'bg-slate-700 text-slate-200'}`;
            msgBubble.innerHTML = text.replace(/\n/g, '<br>');
            msgWrapper.appendChild(msgBubble);
            messageArea.appendChild(msgWrapper);
            scrollToBottom();
        }
        
        function showTypingIndicator() {
            const indicatorWrapper = document.createElement('div');
            indicatorWrapper.id = 'typing-indicator';
            indicatorWrapper.className = 'flex justify-start';
            indicatorWrapper.innerHTML = `<div class="bg-slate-700 text-slate-200 rounded-lg p-3 max-w-lg shadow"><div class="typing-indicator"><span></span><span></span><span></span></div></div>`;
            messageArea.appendChild(indicatorWrapper);
            scrollToBottom();
        }

        function removeTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) indicator.remove();
        }
        
        function scrollToBottom() {
             const chatContainer = document.getElementById('chat-container');
             chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        async function getGeminiResponse(prompt, model) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error.message || `HTTP error! status: ${response.status}`); }
            const data = await response.json();
            if (data.candidates?.[0]?.content?.parts?.[0]?.text) return data.candidates[0].content.parts[0].text;
            if (data.promptFeedback?.blockReason) return `Prompt blocked: ${data.promptFeedback.blockReason}`;
            return "Sorry, I couldn't generate a response.";
        }
        
        function updateStorageFolderNameUI(name, isVerified) {
            if (name) {
                storageFolderNameSpan.textContent = name;
                storageFolderNameSpan.title = isVerified ? `Storage: ${name}` : `Permission needed for '${name}'.`;
                storageFolderNameSpan.classList.toggle('text-yellow-400', !isVerified);
            } else {
                storageFolderNameSpan.textContent = 'None';
                storageFolderNameSpan.title = 'No storage folder set.';
                storageFolderNameSpan.classList.remove('text-yellow-400');
            }
        }
        
        // --- PWA Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>

